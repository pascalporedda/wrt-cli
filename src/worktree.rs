use anyhow::{anyhow, Context, Result};
use regex::Regex;
use std::fs;
use std::path::Path;
use std::process::{Command, Stdio};

fn re_space() -> &'static Regex {
    static RE: std::sync::OnceLock<Regex> = std::sync::OnceLock::new();
    RE.get_or_init(|| Regex::new(r"\s+").expect("regex"))
}

fn re_slug() -> &'static Regex {
    static RE: std::sync::OnceLock<Regex> = std::sync::OnceLock::new();
    RE.get_or_init(|| Regex::new(r"[^a-z0-9]+").expect("regex"))
}

pub fn slug(s: &str) -> String {
    let mut s = s.trim().to_lowercase();
    s = re_space().replace_all(&s, "-").to_string();
    s = re_slug().replace_all(&s, "-").to_string();
    s = s.trim_matches('-').to_string();
    if s.is_empty() {
        return "wrt".to_string();
    }
    s
}

pub fn normalize_branch(s: &str) -> String {
    let mut s = s.trim().to_string();
    if let Some(rest) = s.strip_prefix("refs/heads/") {
        s = rest.to_string();
    }
    // Avoid spaces; git is okay with more but keeping it strict helps automation.
    s = re_space().replace_all(&s, "-").to_string();
    s
}

pub fn ensure_dir(dir: &Path) -> Result<()> {
    fs::create_dir_all(dir).with_context(|| format!("mkdir {}", dir.display()))?;
    Ok(())
}

pub fn add(repo_root: &Path, wt_path: &Path, branch: &str, from_ref: &str) -> Result<()> {
    // Prefer creating a new branch. If branch exists, fall back to checking it out.
    if run_git(
        repo_root,
        [
            "show-ref",
            "--verify",
            "--quiet",
            &format!("refs/heads/{branch}"),
        ],
    )
    .is_ok()
    {
        return run_git(
            repo_root,
            [
                "worktree",
                "add",
                wt_path.to_string_lossy().as_ref(),
                branch,
            ],
        );
    }
    run_git(
        repo_root,
        [
            "worktree",
            "add",
            "-b",
            branch,
            wt_path.to_string_lossy().as_ref(),
            from_ref,
        ],
    )
}

pub fn remove(repo_root: &Path, wt_path: &Path, force: bool) -> Result<()> {
    let mut args: Vec<String> = vec!["worktree".into(), "remove".into()];
    if force {
        args.push("--force".into());
    }
    args.push(wt_path.to_string_lossy().to_string());
    run_git_vec(repo_root, &args)
}

pub fn is_dirty(wt_path: &Path) -> Result<bool> {
    let out = Command::new("git")
        .args(["status", "--porcelain"])
        .current_dir(wt_path)
        .output()
        .context("git status")?;
    if !out.status.success() {
        return Err(anyhow!("git status failed"));
    }
    Ok(!String::from_utf8_lossy(&out.stdout).trim().is_empty())
}

pub fn write_env_file(wt_path: &Path, a: &crate::state::Allocation) -> Result<()> {
    // A tiny env file that can be sourced, and can be read by tooling/scripts.
    // Intentionally avoids setting PORT/VITE_PORT etc by default (too repo-specific).
    let p = wt_path.join(".wrt.env");
    let content = format!(
        "# Generated by wrt. Safe to edit; re-running wrt may overwrite.\nWRT_NAME={}\nWRT_BRANCH={}\nWRT_PORT_BLOCK={}\nWRT_PORT_OFFSET={}\n",
        a.name, a.branch, a.block, a.offset
    );
    fs::write(&p, content.as_bytes()).with_context(|| format!("write {}", p.display()))?;
    Ok(())
}

fn run_git<I, S>(dir: &Path, args: I) -> Result<()>
where
    I: IntoIterator<Item = S>,
    S: AsRef<std::ffi::OsStr>,
{
    let status = Command::new("git")
        .args(args)
        .current_dir(dir)
        // Keep output visible for troubleshooting.
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .status()
        .context("run git")?;
    if !status.success() {
        return Err(anyhow!("git command failed"));
    }
    Ok(())
}

fn run_git_vec(dir: &Path, args: &[String]) -> Result<()> {
    let status = Command::new("git")
        .args(args)
        .current_dir(dir)
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .status()
        .context("run git")?;
    if !status.success() {
        return Err(anyhow!("git command failed"));
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn slug_basic() {
        assert_eq!(slug("a/gpt/fix-login-timeout"), "a-gpt-fix-login-timeout");
        assert_eq!(slug("  Hello   World  "), "hello-world");
        assert_eq!(slug("***"), "wrt");
    }

    #[test]
    fn normalize_branch_basic() {
        assert_eq!(normalize_branch("refs/heads/a/b"), "a/b");
        assert_eq!(normalize_branch("hello world"), "hello-world");
    }
}
