use anyhow::{anyhow, Context, Result};
use regex::Regex;
use std::fs;
use std::path::Path;
use std::process::{Command, Stdio};

fn re_space() -> &'static Regex {
    static RE: std::sync::OnceLock<Regex> = std::sync::OnceLock::new();
    RE.get_or_init(|| Regex::new(r"\s+").expect("regex"))
}

fn re_slug() -> &'static Regex {
    static RE: std::sync::OnceLock<Regex> = std::sync::OnceLock::new();
    RE.get_or_init(|| Regex::new(r"[^a-z0-9]+").expect("regex"))
}

pub fn slug(s: &str) -> String {
    let mut s = s.trim().to_lowercase();
    s = re_space().replace_all(&s, "-").to_string();
    s = re_slug().replace_all(&s, "-").to_string();
    s = s.trim_matches('-').to_string();
    if s.is_empty() {
        return "wrt".to_string();
    }
    s
}

pub fn normalize_branch(s: &str) -> String {
    let mut s = s.trim().to_string();
    if let Some(rest) = s.strip_prefix("refs/heads/") {
        s = rest.to_string();
    }
    // Avoid spaces; git is okay with more but keeping it strict helps automation.
    s = re_space().replace_all(&s, "-").to_string();
    s
}

pub fn ensure_dir(dir: &Path) -> Result<()> {
    fs::create_dir_all(dir).with_context(|| format!("mkdir {}", dir.display()))?;
    Ok(())
}

pub fn add(repo_root: &Path, wt_path: &Path, branch: &str, from_ref: &str) -> Result<()> {
    let remotes = list_remotes(repo_root)?;
    let remote = pick_remote(&remotes);

    if let Some(remote) = remote {
        run_git(repo_root, ["fetch", "--prune", remote])
            .with_context(|| format!("git fetch --prune {remote}"))?;
    }

    // Prefer existing local branch. If it doesn't exist, check for upstream.
    if git_ok(
        repo_root,
        [
            "show-ref",
            "--verify",
            "--quiet",
            &format!("refs/heads/{branch}"),
        ],
    )? {
        return run_git(
            repo_root,
            [
                "worktree",
                "add",
                wt_path.to_string_lossy().as_ref(),
                branch,
            ],
        );
    }

    if let Some(remote) = remote {
        let remote_ref = format!("refs/remotes/{remote}/{branch}");
        if git_ok(
            repo_root,
            ["show-ref", "--verify", "--quiet", remote_ref.as_str()],
        )? {
            let start_point = format!("{remote}/{branch}");
            run_git(
                repo_root,
                ["branch", "--track", branch, start_point.as_str()],
            )?;
            return run_git(
                repo_root,
                [
                    "worktree",
                    "add",
                    wt_path.to_string_lossy().as_ref(),
                    branch,
                ],
            );
        }
    }

    run_git(
        repo_root,
        [
            "worktree",
            "add",
            "-b",
            branch,
            wt_path.to_string_lossy().as_ref(),
            from_ref,
        ],
    )
}

pub fn remove(repo_root: &Path, wt_path: &Path, force: bool) -> Result<()> {
    let mut args: Vec<String> = vec!["worktree".into(), "remove".into()];
    if force {
        args.push("--force".into());
    }
    args.push(wt_path.to_string_lossy().to_string());
    run_git_vec(repo_root, &args)
}

pub fn is_dirty(wt_path: &Path) -> Result<bool> {
    let out = Command::new("git")
        .args(["status", "--porcelain"])
        .current_dir(wt_path)
        .output()
        .context("git status")?;
    if !out.status.success() {
        return Err(anyhow!("git status failed"));
    }
    Ok(!String::from_utf8_lossy(&out.stdout).trim().is_empty())
}

pub fn write_env_file(wt_path: &Path, a: &crate::state::Allocation) -> Result<()> {
    // A tiny env file that can be sourced, and can be read by tooling/scripts.
    // Intentionally avoids setting PORT/VITE_PORT etc by default (too repo-specific).
    let p = wt_path.join(".wrt.env");
    let content = format!(
        "# Generated by wrt. Safe to edit; re-running wrt may overwrite.\nWRT_NAME={}\nWRT_BRANCH={}\nWRT_PORT_BLOCK={}\nWRT_PORT_OFFSET={}\n",
        a.name, a.branch, a.block, a.offset
    );
    fs::write(&p, content.as_bytes()).with_context(|| format!("write {}", p.display()))?;
    Ok(())
}

pub fn copy_repo_env(repo_root: &Path, wt_path: &Path) -> Result<bool> {
    let src = repo_root.join(".env");
    if !src.is_file() {
        return Ok(false);
    }
    let dst = wt_path.join(".env");
    if dst.exists() {
        return Ok(false);
    }
    fs::copy(&src, &dst).with_context(|| format!("copy {} -> {}", src.display(), dst.display()))?;
    Ok(true)
}

fn run_git<I, S>(dir: &Path, args: I) -> Result<()>
where
    I: IntoIterator<Item = S>,
    S: AsRef<std::ffi::OsStr>,
{
    let status = Command::new("git")
        .args(args)
        .current_dir(dir)
        // Keep output visible for troubleshooting.
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .status()
        .context("run git")?;
    if !status.success() {
        return Err(anyhow!("git command failed"));
    }
    Ok(())
}

fn git_ok<I, S>(dir: &Path, args: I) -> Result<bool>
where
    I: IntoIterator<Item = S>,
    S: AsRef<std::ffi::OsStr>,
{
    let status = Command::new("git")
        .args(args)
        .current_dir(dir)
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .context("run git")?;
    Ok(status.success())
}

fn git_out<I, S>(dir: &Path, args: I) -> Result<String>
where
    I: IntoIterator<Item = S>,
    S: AsRef<std::ffi::OsStr>,
{
    let out = Command::new("git")
        .args(args)
        .current_dir(dir)
        .output()
        .context("run git")?;
    if !out.status.success() {
        return Err(anyhow!("git command failed"));
    }
    Ok(String::from_utf8_lossy(&out.stdout).to_string())
}

fn list_remotes(repo_root: &Path) -> Result<Vec<String>> {
    let out = git_out(repo_root, ["remote"])?;
    Ok(out
        .lines()
        .map(|line| line.trim().to_string())
        .filter(|line| !line.is_empty())
        .collect())
}

fn pick_remote(remotes: &[String]) -> Option<&str> {
    if remotes.is_empty() {
        return None;
    }
    for r in remotes {
        if r == "origin" {
            return Some(r.as_str());
        }
    }
    remotes.first().map(|r| r.as_str())
}

fn run_git_vec(dir: &Path, args: &[String]) -> Result<()> {
    let status = Command::new("git")
        .args(args)
        .current_dir(dir)
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .status()
        .context("run git")?;
    if !status.success() {
        return Err(anyhow!("git command failed"));
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn slug_basic() {
        assert_eq!(slug("a/gpt/fix-login-timeout"), "a-gpt-fix-login-timeout");
        assert_eq!(slug("  Hello   World  "), "hello-world");
        assert_eq!(slug("***"), "wrt");
    }

    #[test]
    fn normalize_branch_basic() {
        assert_eq!(normalize_branch("refs/heads/a/b"), "a/b");
        assert_eq!(normalize_branch("hello world"), "hello-world");
    }
}
